From 683225db98c2df2a8aca838a7a028993cc184ed8 Mon Sep 17 00:00:00 2001
From: Hao Sun <sunhao.th@gmail.com>
Date: Wed, 27 Nov 2024 20:13:39 +0100
Subject: [PATCH 04/13] convert smt expr to bcf expr

Convert SMT expr to BCF expr.

Signed-off-by: Hao Sun <hao.sun@inf.ethz.ch>

---
 src/proof/alf/alf_print_channel.cpp | 400 +++++++++++++++++++++++++++-
 src/proof/alf/alf_print_channel.h   |  55 ++++
 src/proof/alf/alf_printer.cpp       |  22 +-
 src/proof/alf/alf_printer.h         |   7 +-
 src/proof/alf/bcf.h                 | 301 +++++++++++++++++++++
 5 files changed, 769 insertions(+), 16 deletions(-)
 create mode 100644 src/proof/alf/bcf.h

diff --git a/src/proof/alf/alf_print_channel.cpp b/src/proof/alf/alf_print_channel.cpp
index 547066d9c7..faf018fa8c 100644
--- a/src/proof/alf/alf_print_channel.cpp
+++ b/src/proof/alf/alf_print_channel.cpp
@@ -17,11 +17,13 @@

 #include <sstream>

+#include "bcf.h"
 #include "expr/node_algorithm.h"
 #include "expr/skolem_manager.h"
 #include "printer/printer.h"
 #include "proof/trust_id.h"
 #include "rewriter/rewrite_db.h"
+#include "util/bitvector.h"

 namespace cvc5::internal {
 namespace proof {
@@ -32,10 +34,7 @@ AlfPrintChannel::~AlfPrintChannel() {}

 void AlfPrintChannel::printLetList(LetBinding& lbind) {}

-std::ostream& AlfPrintChannel::getOStream()
-{
-  return std::cout;
-}
+std::ostream& AlfPrintChannel::getOStream() { return std::cout; }

 AlfPrintChannelOut::AlfPrintChannelOut(std::ostream& out,
                                        const LetBinding* lbind,
@@ -196,10 +195,7 @@ void AlfPrintChannelOut::printLetList(LetBinding& lbind)
   }
 }

-std::ostream& AlfPrintChannelOut::getOStream()
-{
-  return d_out;
-}
+std::ostream& AlfPrintChannelOut::getOStream() { return d_out; }

 void AlfPrintChannelOut::printNodeInternal(std::ostream& out, Node n)
 {
@@ -278,5 +274,393 @@ void AlfPrintChannelPre::processInternal(const Node& n)
   d_keep.insert(n);  // probably not necessary
 }

+/* BCF Channel */
+AlfPrintChannelBCF::AlfPrintChannelBCF(LetBinding* lbind) : d_lbind(lbind)
+{
+  Assert(lbind);
+}
+
+u32 AlfPrintChannelBCF::addExpr(struct bcf_expr* expr)
+{
+  u32 ret = d_exprs.size();
+  d_exprs.push_back(*(u32*)expr);
+  for (int i = 0; i < expr->vlen; i++) d_exprs.push_back(expr->args[i]);
+  return ret;
+}
+
+u32 AlfPrintChannelBCF::addStep(struct bcf_proof_step* step)
+{
+  u32 ret = d_steps.size();
+  d_exprs.push_back(*(u32*)step);
+  for (int i = 0; i < step->vlen; i++) d_exprs.push_back(step->args[i]);
+  return ret;
+}
+
+u32 AlfPrintChannelBCF::addNode(Node node)
+{
+  if (!d_ok) return 0;
+
+  /* first, try to find in let id to idx map */
+  u32 l_id = d_lbind->getId(node);
+  if (l_id)
+  {
+    auto it = d_letIdMap.find(l_id);
+    if (it != d_letIdMap.end()) return it->second;
+  }
+
+  /* try to find in node to idx map */
+  auto it = d_nodeIdxMap.find(node);
+  if (it != d_nodeIdxMap.end()) return it->second;
+
+  /* add node */
+  u32 idx = encodeNode(node);
+  if (l_id)
+    d_letIdMap[l_id] = idx;
+  else
+    d_nodeIdxMap[node] = idx;
+
+  return idx;
+}
+
+struct bcf_expr_args
+{
+  u8 code;
+  u8 vlen;
+  u16 params;
+  u32 args[255];
+};
+
+u32 AlfPrintChannelBCF::encodeNode(Node node)
+{
+  static const std::map<Kind, u8> kind_map = {
+
+      // [Kind::BITVECTOR_NOT] = 0,
+      // Kind::BITVECTOR_SDIV = BCF_BV_ALU | BPF_SDIV,
+      // Kind::BITVECTOR_SMOD = BCF_BV_ALU | BPF_SMOD,
+      //  BCF_BV_ALU | BPF_END,
+      {Kind::BITVECTOR_ADD, BCF_BV_ALU | BPF_ADD},
+      {Kind::BITVECTOR_SUB, BCF_BV_ALU | BPF_SUB},
+      {Kind::BITVECTOR_MULT, BCF_BV_ALU | BPF_MUL},
+      {Kind::BITVECTOR_OR, BCF_BV_ALU | BPF_OR},
+      {Kind::BITVECTOR_AND, BCF_BV_ALU | BPF_AND},
+      {Kind::BITVECTOR_SHL, BCF_BV_ALU | BPF_LSH},
+      {Kind::BITVECTOR_LSHR, BCF_BV_ALU | BPF_RSH},
+      {Kind::BITVECTOR_ASHR, BCF_BV_ALU | BPF_ARSH},
+      {Kind::BITVECTOR_XOR, BCF_BV_ALU | BPF_XOR},
+      {Kind::BITVECTOR_UDIV, BCF_BV_ALU | BPF_DIV},
+      {Kind::BITVECTOR_NEG, BCF_BV_ALU | BPF_NEG},
+      {Kind::BITVECTOR_UREM, BCF_BV_ALU | BPF_MOD},
+
+      {Kind::BITVECTOR_UGT, BCF_BV_PRED | BPF_JGT},
+      {Kind::BITVECTOR_UGE, BCF_BV_PRED | BPF_JGE},
+      {Kind::BITVECTOR_SGT, BCF_BV_PRED | BPF_JSGT},
+      {Kind::BITVECTOR_SGE, BCF_BV_PRED | BPF_JSGE},
+      {Kind::BITVECTOR_ULT, BCF_BV_PRED | BPF_JLT},
+      {Kind::BITVECTOR_ULE, BCF_BV_PRED | BPF_JLE},
+      {Kind::BITVECTOR_SLT, BCF_BV_PRED | BPF_JSLT},
+      {Kind::BITVECTOR_SLE, BCF_BV_PRED | BPF_JSLE},
+      {Kind::BITVECTOR_BIT, BCF_BV_PRED | BCF_BITOF},
+
+      {Kind::BITVECTOR_EXTRACT, BCF_BV_EXT | BCF_EXTRACT},
+      {Kind::BITVECTOR_ZERO_EXTEND, BCF_BV_EXT | BCF_ZERO_EXTEND},
+      {Kind::BITVECTOR_SIGN_EXTEND, BCF_BV_EXT | BCF_SIGN_EXTEND},
+      {Kind::BITVECTOR_FROM_BOOLS, BCF_BV_EXT | BCF_BBT},
+      {Kind::BITVECTOR_CONCAT, BCF_BV_EXT | BCF_CONCAT},
+
+      {Kind::CONST_BITVECTOR, BCF_BV_EXT | BCF_VAL},
+      {Kind::CONST_BOOLEAN, BCF_PRED_EXT | BCF_VAL},
+
+      {Kind::NOT, BCF_PRED_EXT | BCF_NOT},
+      {Kind::AND, BCF_PRED_EXT | BCF_CONJ},
+      {Kind::IMPLIES, BCF_PRED_EXT | BCF_IMPLIES},
+      {Kind::OR, BCF_PRED_EXT | BCF_DISJ},
+      {Kind::XOR, BCF_PRED_EXT | BCF_XOR},
+      {Kind::ITE, BCF_PRED_EXT | BCF_ITE},
+
+      /* overloaded, determine sort later */
+      {Kind::VARIABLE, BCF_BV_EXT | BCF_VAR},
+      /* overloaded, decide the code later */
+      {Kind::EQUAL, BCF_BV_PRED | BPF_JEQ},
+      // [Kind::EQUAL] = BCF_PRED_EXT | BCF_EQUIV,
+  };
+
+  TypeNode ty = node.getType();
+  Kind kind = node.getKind();
+  struct bcf_expr_args expr = {0};
+  auto it = kind_map.find(kind);
+  if (node.getNumChildren() > UINT8_MAX
+      || (ty.isBitVector() && ty.getBitVectorSize() > UINT8_MAX)
+      || it == kind_map.end())
+    goto err_out;
+
+  expr.code = it->second;
+  expr.vlen = node.getNumChildren();
+  if (ty.isBitVector())
+  {
+    expr.params = ty.getBitVectorSize();
+  }
+  for (int i = 0; i < expr.vlen; i++)
+  {
+    expr.args[i] = addNode(node[i]);
+    if (!d_ok) return 0;
+  }
+
+  switch (kind)
+  {
+    case Kind::BITVECTOR_ADD:
+    case Kind::BITVECTOR_SUB:
+    case Kind::BITVECTOR_MULT:
+    case Kind::BITVECTOR_OR:
+    case Kind::BITVECTOR_AND:
+    case Kind::BITVECTOR_XOR:
+    case Kind::BITVECTOR_CONCAT:
+    case Kind::BITVECTOR_FROM_BOOLS:
+    case Kind::BITVECTOR_SHL:
+    case Kind::BITVECTOR_LSHR:
+    case Kind::BITVECTOR_ASHR:
+    case Kind::BITVECTOR_UDIV:
+    case Kind::BITVECTOR_UREM:
+    case Kind::BITVECTOR_NEG:
+
+    case Kind::NOT:
+    case Kind::AND:
+    case Kind::IMPLIES:
+    case Kind::OR:
+    case Kind::XOR:
+    case Kind::ITE: break;
+
+    case Kind::BITVECTOR_UGT:
+    case Kind::BITVECTOR_UGE:
+    case Kind::BITVECTOR_SGT:
+    case Kind::BITVECTOR_SGE:
+    case Kind::BITVECTOR_ULT:
+    case Kind::BITVECTOR_ULE:
+    case Kind::BITVECTOR_SLT:
+    case Kind::BITVECTOR_SLE:
+    {
+      TypeNode cmp_ty = node[0].getType();
+      Assert(expr.vlen == 2);
+      expr.params = cmp_ty.getBitVectorSize();
+      if (cmp_ty.getBitVectorSize() > UINT8_MAX) goto err_out;
+      break;
+    }
+
+    case Kind::BITVECTOR_BIT:
+      Assert(node.getNumChildren() == 1);
+      expr.params = node.getOperator().getConst<BitVectorBit>().d_bitIndex;
+      break;
+
+    case Kind::BITVECTOR_EXTRACT:
+    {
+      BitVectorExtract p = node.getConst<BitVectorExtract>();
+      if (p.d_high > UINT8_MAX || p.d_low > UINT8_MAX) goto err_out;
+      expr.params = p.d_low;
+      expr.params |= (u16)p.d_high << 8;
+      break;
+    }
+
+    case Kind::BITVECTOR_ZERO_EXTEND:
+    {
+      u32 ext = node.getConst<BitVectorZeroExtend>().d_zeroExtendAmount;
+      if (ext > UINT8_MAX) goto err_out;
+      expr.params |= (u16)ext << 8;
+      break;
+    }
+    case Kind::BITVECTOR_SIGN_EXTEND:
+    {
+      u32 ext = node.getConst<BitVectorSignExtend>().d_signExtendAmount;
+      if (ext > UINT8_MAX) goto err_out;
+      expr.params |= (u16)ext << 8;
+      break;
+    }
+
+    case Kind::CONST_BITVECTOR:
+    {
+      const BitVector& bv = node.getConst<BitVector>();
+      if (bv.getSize() > 64) goto err_out;
+      u64 val = bv.getValue().getUnsigned64();
+      expr.args[0] = val;
+      expr.vlen = 1;
+      if (bv.getSize() > 32)
+      {
+        expr.args[1] = val >> 32;
+        expr.vlen++;
+      }
+      break;
+    }
+    case Kind::CONST_BOOLEAN:
+    {
+      expr.code = BCF_PRED_EXT | BCF_VAL;
+      expr.vlen = 0;
+      expr.params = node.getConst<bool>() ? BCF_TRUE : BCF_FALSE;
+      break;
+    }
+
+    /* overloaded, determine sort later */
+    case Kind::VARIABLE:
+      expr.vlen = 0;
+      if (ty.isBitVector())
+        expr.code = BCF_BV_EXT | BCF_VAR;
+      else if (ty.isBoolean())
+        expr.code = BCF_PRED_EXT | BCF_VAR;
+      else
+        goto err_out;
+      break;
+
+    /* overloaded, decide the code later */
+    case Kind::EQUAL:
+    {
+      TypeNode eq_ty = node[0].getType();
+      Assert(expr.vlen == 2);
+
+      if (eq_ty.isBitVector())
+      {
+        expr.code = BCF_BV_ALU | BPF_JEQ;
+        expr.params = eq_ty.getBitVectorSize();
+        if (eq_ty.getBitVectorSize() > UINT8_MAX) goto err_out;
+      }
+      else if (eq_ty.isBoolean())
+      {
+        expr.code = BCF_PRED_EXT | BCF_EQUIV;
+      }
+      else
+      {
+        goto err_out;
+      }
+      break;
+    }
+
+    /* TODO handle LIST */
+    default: goto err_out;
+  }
+
+  return addExpr((struct bcf_expr*)&expr);
+
+err_out:
+  d_ok = false;
+  return 0;
+}
+
+void AlfPrintChannelBCF::printAssume(TNode n, size_t i, bool isPush)
+{
+  if (isPush)
+  {
+    d_ok = false;
+    return;
+  }
+  // TODO
+  return;
+}
+
+void AlfPrintChannelBCF::printStep(ProofRule r,
+                                   const std::string& rname,
+                                   TNode n,
+                                   size_t i,
+                                   const std::vector<size_t>& premises,
+                                   const std::vector<Node>& args,
+                                   bool isPop)
+{
+  // TODO
+  return;
+}
+
+void AlfPrintChannelBCF::printTrustStep(ProofRule r,
+                                        TNode n,
+                                        size_t i,
+                                        const std::vector<size_t>& premises,
+                                        const std::vector<Node>& args,
+                                        TNode nc)
+{
+  // TODO
+  return;
+}
+
+void AlfPrintChannelBCF::printLetList(LetBinding& lbind)
+{
+  // TODO
+  return;
+}
+
+u32 AlfPrintChannelBCF::encodeStep(ProofRule rule,
+                                   TNode conclusion,
+                                   size_t step_id,
+                                   const std::vector<size_t>& premises,
+                                   const std::vector<Node>& args)
+{
+  static const std::map<ProofRule, u16> rule_table = {
+      {ProofRule::ASSUME, BCF_RULE_ASSUME | BCF_RULE_BUILTIN},
+
+      {ProofRule::REFL, BCF_RULE_REFL | BCF_RULE_EQUALITY},
+      {ProofRule::SYMM, BCF_RULE_SYMM | BCF_RULE_EQUALITY},
+      {ProofRule::TRANS, BCF_RULE_TRANS | BCF_RULE_EQUALITY},
+      {ProofRule::CONG, BCF_RULE_CONG | BCF_RULE_EQUALITY},
+      {ProofRule::NARY_CONG, BCF_RULE_CONG | BCF_RULE_EQUALITY},
+      // {ProofRule::HO_CONG, BCF_RULE_CONG | BCF_RULE_EQUALITY},
+      {ProofRule::TRUE_INTRO, BCF_RULE_TRUE_INTRO | BCF_RULE_EQUALITY},
+      {ProofRule::TRUE_ELIM, BCF_RULE_TRUE_ELIM | BCF_RULE_EQUALITY},
+      {ProofRule::FALSE_INTRO, BCF_RULE_FALSE_INTRO | BCF_RULE_EQUALITY},
+      {ProofRule::FALSE_ELIM, BCF_RULE_FALSE_ELIM | BCF_RULE_EQUALITY},
+
+      {ProofRule::FACTORING, BCF_RULE_FACTORING | BCF_RULE_BOOLEAN},
+      {ProofRule::REORDERING, BCF_RULE_REORDERING | BCF_RULE_BOOLEAN},
+      {ProofRule::RESOLUTION, BCF_RULE_RESOLUTION | BCF_RULE_BOOLEAN},
+      {ProofRule::CHAIN_RESOLUTION,
+       BCF_RULE_CHAIN_RESOLUTION | BCF_RULE_BOOLEAN},
+      {ProofRule::SPLIT, BCF_RULE_SPLIT | BCF_RULE_BOOLEAN},
+      {ProofRule::EQ_RESOLVE, BCF_RULE_EQ_RESOLVE | BCF_RULE_BOOLEAN},
+      {ProofRule::MODUS_PONENS, BCF_RULE_MODUS_PONENS | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_NOT_ELIM, BCF_RULE_NOT_NOT_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::CONTRA, BCF_RULE_CONTRA | BCF_RULE_BOOLEAN},
+      {ProofRule::AND_ELIM, BCF_RULE_AND_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::AND_INTRO, BCF_RULE_AND_INTRO | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_OR_ELIM, BCF_RULE_NOT_OR_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::IMPLIES_ELIM, BCF_RULE_IMPLIES_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_IMPLIES_ELIM1,
+       BCF_RULE_NOT_IMPLIES_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_IMPLIES_ELIM2,
+       BCF_RULE_NOT_IMPLIES_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::EQUIV_ELIM1, BCF_RULE_EQUIV_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::EQUIV_ELIM2, BCF_RULE_EQUIV_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_EQUIV_ELIM1, BCF_RULE_NOT_EQUIV_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_EQUIV_ELIM2, BCF_RULE_NOT_EQUIV_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::XOR_ELIM1, BCF_RULE_XOR_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::XOR_ELIM2, BCF_RULE_XOR_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_XOR_ELIM1, BCF_RULE_NOT_XOR_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_XOR_ELIM2, BCF_RULE_NOT_XOR_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::ITE_ELIM1, BCF_RULE_ITE_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::ITE_ELIM2, BCF_RULE_ITE_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_ITE_ELIM1, BCF_RULE_NOT_ITE_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_ITE_ELIM2, BCF_RULE_NOT_ITE_ELIM | BCF_RULE_BOOLEAN},
+      {ProofRule::NOT_AND, BCF_RULE_NOT_AND | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_AND_NEG, BCF_RULE_CNF_AND_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_AND_POS, BCF_RULE_CNF_AND_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_OR_POS, BCF_RULE_CNF_OR_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_OR_NEG, BCF_RULE_CNF_OR_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_IMPLIES_POS, BCF_RULE_CNF_IMPLIES_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_IMPLIES_NEG1,
+       BCF_RULE_CNF_IMPLIES_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_IMPLIES_NEG2,
+       BCF_RULE_CNF_IMPLIES_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_EQUIV_POS1, BCF_RULE_CNF_EQUIV_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_EQUIV_POS2, BCF_RULE_CNF_EQUIV_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_EQUIV_NEG1, BCF_RULE_CNF_EQUIV_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_EQUIV_NEG2, BCF_RULE_CNF_EQUIV_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_XOR_POS1, BCF_RULE_CNF_XOR_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_XOR_POS2, BCF_RULE_CNF_XOR_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_XOR_NEG1, BCF_RULE_CNF_XOR_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_XOR_NEG2, BCF_RULE_CNF_XOR_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_ITE_POS1, BCF_RULE_CNF_ITE_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_ITE_POS2, BCF_RULE_CNF_ITE_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_ITE_POS3, BCF_RULE_CNF_ITE_POS | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_ITE_NEG1, BCF_RULE_CNF_ITE_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_ITE_NEG2, BCF_RULE_CNF_ITE_NEG | BCF_RULE_BOOLEAN},
+      {ProofRule::CNF_ITE_NEG3, BCF_RULE_CNF_ITE_NEG | BCF_RULE_BOOLEAN},
+
+      {ProofRule::BV_BITBLAST_STEP, BCF_RULE_BITBLAST | BCF_RULE_BV},
+  };
+  // TODO
+  return 0;
+}
+
 }  // namespace proof
 }  // namespace cvc5::internal
diff --git a/src/proof/alf/alf_print_channel.h b/src/proof/alf/alf_print_channel.h
index e60cf3bf40..854b885d0c 100644
--- a/src/proof/alf/alf_print_channel.h
+++ b/src/proof/alf/alf_print_channel.h
@@ -24,6 +24,7 @@
 #include "expr/node.h"
 #include "printer/let_binding.h"
 #include "proof/proof_node.h"
+#include "bcf.h"

 namespace cvc5::internal {
 namespace proof {
@@ -170,6 +171,60 @@ class AlfPrintChannelPre : public AlfPrintChannel
   void processInternal(const Node& n);
 };

+/** Prints the proof in BCF format */
+class AlfPrintChannelBCF : public AlfPrintChannel
+{
+ public:
+  typedef uint32_t u32;
+
+  AlfPrintChannelBCF(LetBinding* lbind);
+
+  /* don't care */
+  void printNode(TNode n) override {};
+  void printTypeNode(TypeNode tn) override {};
+
+  /* encode the assume step, isPush must be false */
+  void printAssume(TNode n, size_t i, bool isPush) override;
+  void printStep(ProofRule r,
+                 const std::string& rname,
+                 TNode n,
+                 size_t i,
+                 const std::vector<size_t>& premises,
+                 const std::vector<Node>& args,
+                 bool isPop = false) override;
+  void printTrustStep(ProofRule r,
+                      TNode n,
+                      size_t i,
+                      const std::vector<size_t>& premises,
+                      const std::vector<Node>& args,
+                      TNode conc) override;
+  void printLetList(LetBinding& lbind) override;
+
+  bool getEncodedProof(u32 &proof, u32 &size);
+
+ private:
+  u32 encodeNode(Node n);
+  u32 encodeStep(ProofRule rule,
+                 TNode conclusion,
+                 size_t step_id,
+                 const std::vector<size_t>& premises,
+                 const std::vector<Node>& args);
+
+  u32 addExpr(struct bcf_expr *expr);
+  u32 addStep(struct bcf_proof_step *step);
+  u32 addNode(Node node);
+
+  /** The let binding */
+  LetBinding* d_lbind;
+  /* From let expr id to idx in d_exprs */
+  std::map<u32, u32> d_letIdMap;
+  /* From node to idx in d_exprs */
+  std::map<Node, u32> d_nodeIdxMap;
+  std::vector<u32> d_exprs;
+  std::vector<u32> d_steps;
+  bool d_ok = true;
+};
+
 }  // namespace proof
 }  // namespace cvc5::internal

diff --git a/src/proof/alf/alf_printer.cpp b/src/proof/alf/alf_printer.cpp
index 9cc8a606f2..44f9dcdfa5 100644
--- a/src/proof/alf/alf_printer.cpp
+++ b/src/proof/alf/alf_printer.cpp
@@ -41,7 +41,8 @@ namespace proof {
 AlfPrinter::AlfPrinter(Env& env,
                        BaseAlfNodeConverter& atp,
                        rewriter::RewriteDb* rdb,
-                       uint32_t letThresh)
+                       uint32_t letThresh,
+                       bool bcfFormat)
     : EnvObj(env),
       d_tproc(atp),
       d_pfIdCounter(0),
@@ -57,20 +58,20 @@ AlfPrinter::AlfPrinter(Env& env,
       // utility.
       d_lbind(d_termLetPrefix, letThresh, true, true),
       d_lbindUse(options().proof.proofDagGlobal ? &d_lbind : nullptr),
-      d_aletify(d_lbindUse)
+      d_aletify(d_lbindUse),
+      d_bcfFormat(bcfFormat)
 {
   d_pfType = nodeManager()->mkSort("proofType");
   d_false = nodeManager()->mkConst(false);
 }

-bool AlfPrinter::isHandled(const Options& opts, const ProofNode* pfn)
+bool AlfPrinter::isHandled(const Options& opts, const ProofNode* pfn, bool bcfFormat)
 {
   const std::vector<Node> pargs = pfn->getArguments();
   switch (pfn->getRule())
   {
     // List of handled rules
     case ProofRule::ASSUME:
-    case ProofRule::SCOPE:
     case ProofRule::REFL:
     case ProofRule::SYMM:
     case ProofRule::TRANS:
@@ -105,6 +106,7 @@ bool AlfPrinter::isHandled(const Options& opts, const ProofNode* pfn)
     case ProofRule::NOT_ITE_ELIM1:
     case ProofRule::NOT_ITE_ELIM2:
     case ProofRule::NOT_AND:
+    case ProofRule::CNF_AND_POS:
     case ProofRule::CNF_AND_NEG:
     case ProofRule::CNF_OR_POS:
     case ProofRule::CNF_OR_NEG:
@@ -125,11 +127,19 @@ bool AlfPrinter::isHandled(const Options& opts, const ProofNode* pfn)
     case ProofRule::CNF_ITE_NEG1:
     case ProofRule::CNF_ITE_NEG2:
     case ProofRule::CNF_ITE_NEG3:
-    case ProofRule::CNF_AND_POS:
     case ProofRule::FACTORING:
     case ProofRule::REORDERING:
     case ProofRule::RESOLUTION:
     case ProofRule::CHAIN_RESOLUTION:
+      return true;
+    default:
+      if (bcfFormat)
+        return false;
+      break;
+  }
+
+  switch (pfn->getRule()) {
+    case ProofRule::SCOPE:
     case ProofRule::ARRAYS_READ_OVER_WRITE:
     case ProofRule::ARRAYS_READ_OVER_WRITE_CONTRA:
     case ProofRule::ARRAYS_READ_OVER_WRITE_1:
@@ -938,7 +948,7 @@ void AlfPrinter::printStepPost(AlfPrintChannel* out, const ProofNode* pn)
   TNode conclusion = d_tproc.convert(pn->getResult());
   TNode conclusionPrint;
   // print conclusion only if option is set, or this is false
-  if (options().proof.proofPrintConclusion || conclusion == d_false)
+  if (options().proof.proofPrintConclusion || conclusion == d_false || d_bcfFormat)
   {
     conclusionPrint = conclusion;
   }
diff --git a/src/proof/alf/alf_printer.h b/src/proof/alf/alf_printer.h
index 0a7bf83c1b..a1c0f24394 100644
--- a/src/proof/alf/alf_printer.h
+++ b/src/proof/alf/alf_printer.h
@@ -44,7 +44,8 @@ class AlfPrinter : protected EnvObj
   AlfPrinter(Env& env,
              BaseAlfNodeConverter& atp,
              rewriter::RewriteDb* rdb,
-             uint32_t letThresh = 2);
+             uint32_t letThresh = 2,
+             bool bcfFormat = false);
   ~AlfPrinter() {}

   /**
@@ -89,7 +90,7 @@ class AlfPrinter : protected EnvObj
   LetBinding* getLetBinding();

   /** Return true if it is possible to trust the topmost application in pfn */
-  static bool isHandled(const Options& opts, const ProofNode* pfn);
+  static bool isHandled(const Options& opts, const ProofNode* pfn, bool bcfFormat = false);

  private:
   /** Return true if id is handled as a theory rewrite for term n */
@@ -196,6 +197,8 @@ class AlfPrinter : protected EnvObj
   LetBinding* d_lbindUse;
   /** The letification channel. */
   AlfPrintChannelPre d_aletify;
+  /* print to bcf format. */
+  bool d_bcfFormat;
 };

 }  // namespace proof
diff --git a/src/proof/alf/bcf.h b/src/proof/alf/bcf.h
new file mode 100644
index 0000000000..b9c6f20fe1
--- /dev/null
+++ b/src/proof/alf/bcf.h
@@ -0,0 +1,301 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+#ifndef __LINUX_BCF_H__
+#define __LINUX_BCF_H__
+
+#include <linux/types.h>
+#include <linux/bpf_common.h>
+#include <linux/bpf.h>
+#include <stdint.h>
+
+/* BCF expression classes */
+#define BCF_BV_ALU 0x00
+#define BCF_BV_EXT 0x01
+#define BCF_BV_PRED 0x02
+#define BCF_PRED_EXT 0x03
+#define BCF_BUILTIN 0x04
+
+/* BCF bitvec extended operations (BCF_BV_EXT) */
+#define BCF_VAR 0x00
+#define BCF_VAL 0x10
+#define BCF_BBT 0x20
+#define BCF_EXTRACT 0x30
+#define BCF_SIGN_EXTEND 0x40
+#define BCF_ZERO_EXTEND 0x50
+#define BCF_CONCAT 0x60
+
+/* BCF bitvec predicate (BCF_BV_PRED) */
+#define BCF_BITOF 0x00
+
+/* BCF extended predicate operations (BCF_PRED_EXT) */
+#define BCF_CONJ 0x20
+#define BCF_DISJ 0x30
+#define BCF_IMPLIES 0x40
+#define BCF_XOR 0x50
+#define BCF_ITE 0x60
+#define BCF_NOT 0x70
+#define BCF_EQUIV 0x80
+
+#define BCF_TRUE 0x0
+#define BCF_FALSE 0x1
+
+/* BCF builtin expression types (BCF_BUILTIN) */
+#define BCF_ARG_LIST 0x00
+
+struct bcf_expr {
+	__u8 code;
+	/* number of args */
+	__u8 vlen;
+	/* Parameterize the code. For BCF_BV_*, the lower 8 bits is the bitvec
+	 * bit size, and the higher bits are reserved, except: (1) the higher
+	 * bits mean the extended bits for zero/sign extension, (2) the higher
+	 * and lower mean the start and end of the bit for extraction, and (3)
+	 * the first bit of higher bits is used to indicate signed mod/div.
+	 * For PRED_EXT, the lowest one bit is for BCF_VAL (0/1 for true/false),
+	 * and all bits are reserved for other cases.
+	 */
+	__u16 params;
+	/* arguments (arg_idx), counted by vlen */
+	__u32 args[];
+};
+
+#define BCF_BV_BITSZ(PARAMS) ((PARAMS)&0x00ff)
+#define BCF_BV_EXTSZ(PARAMS) (((PARAMS)&0xff00) >> 8)
+#define BCF_EXTRACT_START(PARAMS) BCF_BV_EXTSZ(PARAMS)
+#define BCF_EXTRACT_LAST(PARAMS) BCF_BV_BITSZ(PARAMS)
+#define BCF_PRED_VAL(PARAMS) ((PARAMS)&0x0001)
+
+#define BCF_MAGIC 0x0BCF
+
+struct bcf_proof_header {
+	__u32 magic;
+	__u32 expr_cnt;
+	__u32 step_cnt;
+};
+
+struct bcf_proof_step {
+	__u16 rule;
+	__u8 vlen;
+	__u8 params;
+	__u32 args[];
+};
+
+#define BCF_STEP_CLASS(rule) ((rule)&0xe000)
+#define BCF_RULE_BUILTIN 0x0000
+#define BCF_RULE_BOOLEAN 0x2000
+#define BCF_RULE_EQUALITY 0x4000
+#define BCF_RULE_BV 0x6000
+
+#define BCF_STEP_RULE(step) ((step)&0x1fff)
+
+/* Builtin Rules */
+enum {
+	BCF_RULE_ASSUME = 0,
+	BCF_RULE_REWRITE,
+
+	__MAX_BCF_BUILTIN_RULES,
+};
+
+/* Boolean Rules */
+enum {
+	BCF_RULE_RESOLUTION = 0,
+	BCF_RULE_CHAIN_RESOLUTION,
+	BCF_RULE_FACTORING,
+	BCF_RULE_REORDERING,
+	BCF_RULE_SPLIT,
+	BCF_RULE_EQ_RESOLVE,
+	BCF_RULE_MODUS_PONENS,
+	BCF_RULE_NOT_NOT_ELIM,
+	BCF_RULE_CONTRA,
+	BCF_RULE_AND_ELIM,
+	BCF_RULE_AND_INTRO,
+	BCF_RULE_NOT_OR_ELIM,
+	BCF_RULE_IMPLIES_ELIM,
+	BCF_RULE_NOT_IMPLIES_ELIM,
+	BCF_RULE_EQUIV_ELIM,
+	BCF_RULE_NOT_EQUIV_ELIM,
+	BCF_RULE_XOR_ELIM,
+	BCF_RULE_NOT_XOR_ELIM,
+	BCF_RULE_ITE_ELIM,
+	BCF_RULE_NOT_ITE_ELIM,
+	BCF_RULE_NOT_AND,
+	BCF_RULE_CNF_AND_POS,
+	BCF_RULE_CNF_AND_NEG,
+	BCF_RULE_CNF_OR_POS,
+	BCF_RULE_CNF_OR_NEG,
+	BCF_RULE_CNF_IMPLIES_POS,
+	BCF_RULE_CNF_IMPLIES_NEG,
+	BCF_RULE_CNF_EQUIV_POS,
+	BCF_RULE_CNF_EQUIV_NEG,
+	BCF_RULE_CNF_XOR_POS,
+	BCF_RULE_CNF_XOR_NEG,
+	BCF_RULE_CNF_ITE_POS,
+	BCF_RULE_CNF_ITE_NEG,
+
+	__MAX_BCF_BOOLEAN_RULES,
+};
+
+/* Equality Rules */
+enum {
+	BCF_RULE_REFL = 0,
+	BCF_RULE_SYMM,
+	BCF_RULE_TRANS,
+	BCF_RULE_CONG,
+	BCF_RULE_TRUE_INTRO,
+	BCF_RULE_TRUE_ELIM,
+	BCF_RULE_FALSE_INTRO,
+	BCF_RULE_FALSE_ELIM,
+
+	__MAX_BCF_EQUALITY_RULES,
+};
+
+/* BitVector Rules */
+enum {
+	BCF_RULE_BITBLAST = 0,
+
+	__MAX_BCF_BV_RULES,
+};
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+
+struct bcf_expr_unary {
+	u8 code;
+	u8 vlen;
+	u16 params;
+	u32 arg0;
+};
+
+struct bcf_expr_binary {
+	u8 code;
+	u8 vlen;
+	u16 params;
+	u32 arg0;
+	u32 arg1;
+};
+
+struct bcf_expr_ternary {
+	u8 code;
+	u8 vlen;
+	u16 params;
+	u32 arg0;
+	u32 arg1;
+	u32 arg2;
+};
+
+#define BCF_PRED_TRUE                           \
+	((struct bcf_expr){                     \
+		.code = BCF_PRED_EXT | BCF_VAL, \
+		.vlen = 0,                      \
+		.params = BCF_TRUE,             \
+	})
+
+#define BCF_PRED_FALSE                          \
+	((struct bcf_expr){                     \
+		.code = BCF_PRED_EXT | BCF_VAL, \
+		.vlen = 0,                      \
+		.params = BCF_FALSE,            \
+	})
+
+#define BCF_PRED_NOT(ARG0)                      \
+	((struct bcf_expr_unary){               \
+		.code = BCF_PRED_EXT | BCF_NOT, \
+		.vlen = 1,                      \
+		.params = 0,                    \
+		.arg0 = ARG0,                   \
+	})
+
+#define BCF_PRED_ITE(ARG0, ARG1, ARG2)          \
+	((struct bcf_expr_ternary){             \
+		.code = BCF_PRED_EXT | BCF_ITE, \
+		.vlen = 3,                      \
+		.params = 0,                    \
+		.arg0 = ARG0,                   \
+		.arg1 = ARG1,                   \
+		.arg2 = ARG2,                   \
+	})
+
+#define BCF_PRED_EXPR(OP, ARG0, ARG1)      \
+	((struct bcf_expr_binary){         \
+		.code = BCF_PRED_EXT | OP, \
+		.vlen = 2,                 \
+		.params = 0,               \
+		.arg0 = ARG0,              \
+		.arg1 = ARG1,              \
+	})
+
+#define BCF_PRED_EQUIV(ARG0, ARG1) BCF_PRED_EXPR(BCF_EQUIV, ARG0, ARG1)
+#define BCF_PRED_XOR(ARG0, ARG1) BCF_PRED_EXPR(BCF_XOR, ARG0, ARG1)
+#define BCF_PRED_IMPLES(ARG0, ARG1) BCF_PRED_EXPR(BCF_IMPLIES, ARG0, ARG1)
+
+#define BCF_BV_VAR(BITS)                      \
+	((struct bcf_expr){                   \
+		.code = BCF_BV_EXT | BCF_VAR, \
+		.vlen = 0,                    \
+		.params = BITS,               \
+	})
+
+#define BCF_BV_VAR64 BCF_BV_VAR(64)
+
+#define BCF_BV_VAL32(IMM)                     \
+	((struct bcf_expr_unary){             \
+		.code = BCF_BV_EXT | BCF_VAL, \
+		.vlen = 1,                    \
+		.params = 32,                 \
+		.arg0 = IMM,                  \
+	})
+
+#define BCF_BV_VAL64(IMM)                     \
+	((struct bcf_expr_binary){            \
+		.code = BCF_BV_EXT | BCF_VAL, \
+		.vlen = 2,                    \
+		.params = 64,                 \
+		.arg0 = IMM,                  \
+		.arg1 = (u64)IMM >> 32,       \
+	})
+
+#define BCF_BV_EXTRACT(SIZE, ARG0)                  \
+	((struct bcf_expr_unary){                   \
+		.code = BCF_BV_EXT | BCF_EXTRACT,   \
+		.vlen = 1,                          \
+		.params = ((u16)SIZE - 1) << 8 | 0, \
+		.arg0 = ARG0,                       \
+	})
+
+#define BCF_BV_ZEXT(SIZE, BITSZ, ARG0)                \
+	((struct bcf_expr_unary){                     \
+		.code = BCF_BV_EXT | BCF_ZERO_EXTEND, \
+		.vlen = 1,                            \
+		.params = (u16)SIZE << 8 | BITSZ,     \
+		.arg0 = ARG0,                         \
+	})
+
+#define BCF_BV_SEXT(SIZE, BITSZ, ARG0)                \
+	((struct bcf_expr_unary){                     \
+		.code = BCF_BV_EXT | BCF_SIGN_EXTEND, \
+		.vlen = 1,                            \
+		.params = (u16)SIZE << 8 | BITSZ,     \
+		.arg0 = ARG0,                         \
+	})
+
+#define BCF_EXPR(CODE, ARG0, ARG1, BITS) \
+	((struct bcf_expr_binary){       \
+		.code = CODE,            \
+		.vlen = 2,               \
+		.params = BITS,          \
+		.arg0 = ARG0,            \
+		.arg1 = ARG1,            \
+	})
+
+#define BCF_ALU(OP, ARG0, ARG1, BITS) \
+	BCF_EXPR(BCF_BV_ALU | OP, ARG0, ARG1, BITS)
+#define BCF_ALU32(OP, ARG0, ARG1) BCF_ALU(OP, ARG0, ARG1, 32)
+#define BCF_ALU64(OP, ARG0, ARG1) BCF_ALU(OP, ARG0, ARG1, 64)
+
+#define BCF_PRED(OP, ARG0, ARG1, BITS) \
+	BCF_EXPR(BCF_BV_PRED | OP, ARG0, ARG1, BITS)
+#define BCF_PRED32(OP, ARG0, ARG1) BCF_PRED(OP, ARG0, ARG1, 32)
+#define BCF_PRED64(OP, ARG0, ARG1) BCF_PRED(OP, ARG0, ARG1, 64)
+
+#endif /* __LINUX_BCF_H__ */
--
2.34.1

