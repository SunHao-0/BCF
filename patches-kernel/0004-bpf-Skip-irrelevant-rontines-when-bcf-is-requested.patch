From 5bfedf26509eae0dbe3c6a2ec8a084bb8223025b Mon Sep 17 00:00:00 2001
From: Hao Sun <hao.sun@inf.ethz.ch>
Date: Mon, 24 Feb 2025 16:10:59 +0100
Subject: [PATCH 04/32] bpf: Skip irrelevant routines when bcf is requested

BCF's symbolic tracking is integrated into the verifier's analysis, which
allows BCF to reuse the verifier knowledge. However, this process is only
for refinement, not the real analysis, so several routines are skipped when
the analysis is under BCF.

This includes the following routines:
- push_insn_history: since we only follows the current path.
- __mark_chain_precision: no precision tracking is needed.
- find_prev_entry: no state pruning.
- is_state_visited: no state pruning.
- can_skip_alu_sanitation: no alu sanitation.

Signed-off-by: Hao Sun <hao.sun@inf.ethz.ch>
---
 kernel/bpf/verifier.c | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 4f02345b764f..331024a3413a 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -3553,6 +3553,9 @@ static int push_insn_history(struct bpf_verifier_env *env, struct bpf_verifier_s
 	struct bpf_insn_hist_entry *p;
 	size_t alloc_size;

+	if (bcf_requested(env))
+		return 0;
+
 	/* combine instruction flags if we already recorded this instruction */
 	if (env->cur_hist_ent) {
 		/* atomic instructions push insn_flags twice, for READ and
@@ -4359,7 +4362,7 @@ static int __mark_chain_precision(struct bpf_verifier_env *env, int regno)
 	bool skip_first = true;
 	int i, fr, err;

-	if (!env->bpf_capable)
+	if (!env->bpf_capable || bcf_requested(env))
 		return 0;

 	/* set frame number from which we are starting to backtrack */
@@ -8263,6 +8266,9 @@ static struct bpf_verifier_state *find_prev_entry(struct bpf_verifier_env *env,
 	struct bpf_verifier_state_list *sl;
 	struct bpf_verifier_state *st;

+	if (bcf_requested(env))
+		return NULL;
+
 	/* Explored states are pushed in stack order, most recent states come first */
 	sl = *explored_state(env, insn_idx);
 	for (; sl; sl = sl->next) {
@@ -13192,7 +13198,8 @@ static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,
 static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,
 				    const struct bpf_insn *insn)
 {
-	return env->bypass_spec_v1 || BPF_SRC(insn->code) == BPF_K;
+	return env->bypass_spec_v1 || BPF_SRC(insn->code) == BPF_K ||
+	       bcf_requested(env);
 }

 static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,
@@ -15670,7 +15677,7 @@ static int check_cond_jmp_op(struct bpf_verifier_env *env,
 		 * the fall-through branch for simulation under speculative
 		 * execution.
 		 */
-		if (!env->bypass_spec_v1 &&
+		if (!env->bypass_spec_v1 && !bcf_requested(env) &&
 		    !sanitize_speculative_path(env, insn, *insn_idx + 1,
 					       *insn_idx))
 			return -EFAULT;
@@ -15683,7 +15690,7 @@ static int check_cond_jmp_op(struct bpf_verifier_env *env,
 		 * program will go. If needed, push the goto branch for
 		 * simulation under speculative execution.
 		 */
-		if (!env->bypass_spec_v1 &&
+		if (!env->bypass_spec_v1 && !bcf_requested(env) &&
 		    !sanitize_speculative_path(env, insn,
 					       *insn_idx + insn->off + 1,
 					       *insn_idx))
@@ -18119,6 +18126,9 @@ static int is_state_visited(struct bpf_verifier_env *env, int insn_idx)
 	int i, j, n, err, states_cnt = 0;
 	bool force_new_state, add_new_state, force_exact;

+	if (bcf_requested(env))
+		return 0;
+
 	force_new_state = env->test_state_freq || is_force_checkpoint(env, insn_idx) ||
 			  /* Avoid accumulating infinitely long jmp history */
 			  cur->insn_hist_end - cur->insn_hist_start > 40;
--
2.34.1

