From 5ac3e4d6b2526be55d7c627dbeb66c871e8c85ae Mon Sep 17 00:00:00 2001
From: Hao Sun <hao.sun@inf.ethz.ch>
Date: Tue, 25 Feb 2025 12:19:11 +0100
Subject: [PATCH 09/32] bpf: Tracking stack state in BCF

Add routines to track stack state in BCF. This currently mainly
handles full register spills and fills. In other cases, the stack
state is not tracked, and the register is marked as unbounded
symbolic expression, i.e., over-approximation.

Signed-off-by: Hao Sun <hao.sun@inf.ethz.ch>
---
 kernel/bpf/verifier.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 7ae12351ab09..4c09695416a0 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -4913,6 +4913,9 @@ static void save_register_state(struct bpf_verifier_env *env,
 {
 	int i;

+	if (!tnum_is_const(reg->var_off))
+		bcf_reg_expr(env, reg, false);
+
 	copy_register_state(&state->stack[spi].spilled_ptr, reg);
 	if (size == BPF_REG_SIZE)
 		state->stack[spi].spilled_ptr.live |= REG_LIVE_WRITTEN;
@@ -5020,8 +5023,10 @@ static int check_stack_write_fixed_off(struct bpf_verifier_env *env,
 			assign_scalar_id_before_mov(env, reg);
 		save_register_state(env, state, spi, reg, size);
 		/* Break the relation on a narrowing spill. */
-		if (!reg_value_fits)
+		if (!reg_value_fits) {
 			state->stack[spi].spilled_ptr.id = 0;
+			state->stack[spi].spilled_ptr.bcf_expr = -1;
+		}
 	} else if (!reg && !(off % BPF_REG_SIZE) && is_bpf_st_mem(insn) &&
 		   env->bpf_capable) {
 		struct bpf_reg_state *tmp_reg = &env->fake_reg[0];
@@ -5047,6 +5052,7 @@ static int check_stack_write_fixed_off(struct bpf_verifier_env *env,

 		/* regular write of data into stack destroys any spilled ptr */
 		state->stack[spi].spilled_ptr.type = NOT_INIT;
+		state->stack[spi].spilled_ptr.bcf_expr = -1;
 		/* Mark slots as STACK_MISC if they belonged to spilled ptr/dynptr/iter. */
 		if (is_stack_slot_special(&state->stack[spi]))
 			for (i = 0; i < BPF_REG_SIZE; i++)
@@ -5187,6 +5193,7 @@ static int check_stack_write_var_off(struct bpf_verifier_env *env,

 		/* Erase all other spilled pointers. */
 		state->stack[spi].spilled_ptr.type = NOT_INIT;
+		state->stack[spi].spilled_ptr.bcf_expr = -1;

 		/* Update the slot type. */
 		new_type = STACK_MISC;
@@ -5315,8 +5322,10 @@ static int check_stack_read_fixed_off(struct bpf_verifier_env *env,
 				/* Break the relation on a narrowing fill.
 				 * coerce_reg_to_size will adjust the boundaries.
 				 */
-				if (get_reg_width(reg) > size * BITS_PER_BYTE)
+				if (get_reg_width(reg) > size * BITS_PER_BYTE) {
 					state->regs[dst_regno].id = 0;
+					state->regs[dst_regno].bcf_expr = -1;
+				}
 			} else {
 				int spill_cnt = 0, zero_cnt = 0;

--
2.34.1

