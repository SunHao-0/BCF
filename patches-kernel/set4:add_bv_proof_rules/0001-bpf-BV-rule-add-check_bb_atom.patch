From b502e6af49adcbe4bc6aca5fb390a470928c7d27 Mon Sep 17 00:00:00 2001
From: Hao Sun <hao.sun@inf.ethz.ch>
Date: Tue, 30 Sep 2025 19:12:48 +0200
Subject: [PATCH RFC 1/7] bpf: BV rule: add check_bb_atom()

Validate bit-blasted boolean atoms (comparators) against their BV form.
Given an equality (atom = bbt) where bbt is a from_bool bit-vector, check:
- JEQ: bbt is the conjunction of per-bit equalities
- JLT/JLE: bbt encodes unsigned comparator via recursive decomposition
- JSLT/JSLE: bbt encodes signed comparator (MSB guard + unsigned tail)

Checks follow the textbook bit-blasting encodings for BV comparators.

Signed-off-by: Hao Sun <hao.sun@inf.ethz.ch>
---
 kernel/bpf/bcf_checker.c | 203 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 202 insertions(+), 1 deletion(-)

diff --git a/kernel/bpf/bcf_checker.c b/kernel/bpf/bcf_checker.c
index 20c68e23781c..95f6731254fa 100644
--- a/kernel/bpf/bcf_checker.c
+++ b/kernel/bpf/bcf_checker.c
@@ -627,6 +627,15 @@ static bool valid_arity(u8 code, u8 vlen)
 				_arity[0] BCF_ARGS_PASS_##arity);       \
 	}
 
+#define DEFINE_OPERAND_CHECK_BINARY(_ty, ty_name, _op, op_name, _arity)     \
+	static bool is_##ty_name##_##op_name##_of(                          \
+		struct bcf_checker_state *st, u32 id, u32 arg0, u32 arg1)   \
+	{                                                                   \
+		struct bcf_expr *e = id_to_expr(st, id);                    \
+		return is_##ty_name##_##op_name(e->code) && e->vlen == 2 && \
+		       e->args[0] == arg0 && e->args[1] == arg1;            \
+	}
+
 __diag_push();
 __diag_ignore_all("-Wunused-function",
 		  "Allow unused functions for macro-defined functions");
@@ -640,6 +649,9 @@ BCF_BV_OP_BINARY(DEFINE_EXPR_BUILD)
 BCF_BOOL_OP_BINARY(DEFINE_EXPR_BUILD)
 BCF_BV_OP_TERNARY(DEFINE_EXPR_BUILD)
 BCF_BOOL_OP_TERNARY(DEFINE_EXPR_BUILD)
+
+BCF_BV_OP_BINARY(DEFINE_OPERAND_CHECK_BINARY)
+BCF_BOOL_OP_BINARY(DEFINE_OPERAND_CHECK_BINARY)
 __diag_pop();
 
 static bool is_bool(u8 code)
@@ -691,6 +703,13 @@ static bool is_ite_bool_cond(struct bcf_checker_state *st, struct bcf_expr *e)
 	return !is_bv_ite(e->code) || is_bool(id_to_expr(st, e->args[0])->code);
 }
 
+static bool is_bool_not_of(struct bcf_checker_state *st, u32 not_id, u32 e_id)
+{
+	struct bcf_expr *not_expr = id_to_expr(st, not_id);
+
+	return is_bool_not(not_expr->code) && not_expr->args[0] == e_id;
+}
+
 #define build_disj(st, ...) build_expr(st, BCF_BOOL | BCF_DISJ, 0, __VA_ARGS__)
 #define build_disj_move(st, ...) \
 	build_expr_move(st, BCF_BOOL | BCF_DISJ, 0, __VA_ARGS__)
@@ -3873,16 +3892,198 @@ static int apply_bool_rule(struct bcf_checker_state *st,
 	return -EFAULT;
 }
 
+static bool is_bool_conj2(struct bcf_checker_state *st, u32 e_id)
+{
+	struct bcf_expr *expr = id_to_expr(st, e_id);
+
+	return is_bool_conj(expr->code) && expr->vlen == 2;
+}
+
+/*
+ * Check bitblast bv_ult
+ * bb_ult: Validate canonical bit-blast for unsigned less-than/less-equal.
+ * Structure enforced for bits i = vlen-1..1:
+ *   res = ((lhs[i] == rhs[i]) ∧ rest) ∨ ((¬lhs[i]) ∧ rhs[i]),
+ * descending with rest at each step.
+ * Base (i == 0, strict <): res = ((¬lhs[0]) ∧ rhs[0]).
+ * For ≤ (eq=true): at the base, require a disjunction with equality bit:
+ *   res = ((¬lhs[0]) ∧ rhs[0]) ∨ (lhs[0] == rhs[0]).
+ */
+static int bb_ult(struct bcf_checker_state *st, struct bcf_expr *res, u32 *lhs,
+		  u32 *rhs, u8 vlen, bool eq)
+{
+	struct bcf_expr *l, *r;
+	u32 i;
+
+	if (WARN_ON_ONCE(!vlen))
+		return -EFAULT;
+
+	/* a < b iff ( a[i] <-> b[i] AND a[i-1:0] < b[i-1:0]) OR (~a[i] AND b[i]) */
+	for (i = vlen - 1; i > 0; i--) {
+		ENSURE(is_bool_disj(res->code) && res->vlen == 2);
+		ENSURE(is_bool_conj2(st, res->args[0]));
+		ENSURE(is_bool_conj2(st, res->args[1]));
+
+		r = id_to_expr(st, res->args[1]);
+		ENSURE(is_bool_not_of(st, r->args[0], lhs[i]));
+		ENSURE(r->args[1] == rhs[i]);
+
+		l = id_to_expr(st, res->args[0]);
+		ENSURE(is_bool_eq_of(st, l->args[0], lhs[i], rhs[i]));
+		res = id_to_expr(st, l->args[1]);
+	}
+
+	if (eq) {
+		ENSURE(is_bool_disj(res->code) && res->vlen == 2);
+		ENSURE(is_bool_eq_of(st, res->args[1], lhs[0], rhs[0]));
+		res = id_to_expr(st, res->args[0]);
+	}
+
+	ENSURE(is_bool_conj(res->code) && res->vlen == 2);
+	ENSURE(res->args[1] == rhs[0]);
+	ENSURE(is_bool_not_of(st, res->args[0], lhs[0]));
+	return 0;
+}
+
+/*
+ * Check bitblast bv_slt
+ * bb_slt: Validate canonical bit-blast for signed less-than/less-equal.
+ * MSB index s = vlen-1. Enforce:
+ *   res = ((lhs[s] == rhs[s]) ∧ rest) ∨ (lhs[s] ∧ ¬rhs[s]),
+ * where 'rest' is the unsigned comparator over lower bits (s-1..0),
+ * with eq propagated for ≤.
+ */
+static int bb_slt(struct bcf_checker_state *st, struct bcf_expr *res, u32 *lhs,
+		  u32 *rhs, u32 vlen, bool eq)
+{
+	struct bcf_expr *sign_same, *neg_lhs;
+	u32 sbit;
+
+	ENSURE(vlen > 1);
+	sbit = vlen - 1;
+
+	ENSURE(is_bool_disj(res->code) && res->vlen == 2);
+	ENSURE(is_bool_conj2(st, res->args[0]));
+	ENSURE(is_bool_conj2(st, res->args[1]));
+
+	neg_lhs = id_to_expr(st, res->args[1]);
+	ENSURE(neg_lhs->args[0] == lhs[sbit]);
+	ENSURE(is_bool_not_of(st, neg_lhs->args[1], rhs[sbit]));
+
+	sign_same = id_to_expr(st, res->args[0]);
+	ENSURE(is_bool_eq_of(st, sign_same->args[0], lhs[sbit], rhs[sbit]));
+	/* recurse into lower-bit comparator guarded by equal sign-bit */
+	res = id_to_expr(st, sign_same->args[1]);
+	return bb_ult(st, res, lhs, rhs, vlen - 1, eq);
+}
+
+/*
+ * check_bb_atom: Validate bit-blasted boolean atoms (comparisons).
+ * Inputs (lhs, rhs) must already be bit-blasted vectors (FROM_BOOL) of equal
+ * width. Supported ops:
+ *   - JEQ: conjunction over all bits of (lhs[i] == rhs[i])
+ *   - JLT/JLE: unsigned comparator via bb_ult (eq=false/true)
+ *   - JSLT/JSLE: signed comparator via bb_slt (eq=false/true)
+ * Any other opcode is rejected here (may be rewritten earlier).
+ */
+static int check_bb_atom(struct bcf_checker_state *st, struct bcf_expr *atom,
+			 struct bcf_expr *bbt)
+{
+	u32 *lbits, *rbits, vlen, i;
+	u8 op = BCF_OP(atom->code);
+	bool eq = false;
+
+	switch (op) {
+	case BPF_JLE:
+	case BPF_JSLE:
+	case BPF_JEQ:
+		eq = true;
+		fallthrough;
+	case BPF_JLT:
+	case BPF_JSLT: {
+		struct bcf_expr *lhs, *rhs;
+
+		lhs = id_to_expr(st, atom->args[0]);
+		rhs = id_to_expr(st, atom->args[1]);
+		/* Must be already bitblasted term. */
+		ENSURE(is_bv_from_bool(lhs->code));
+		ENSURE(is_bv_from_bool(rhs->code));
+
+		vlen = lhs->vlen;
+		lbits = lhs->args;
+		rbits = rhs->args;
+		break;
+	}
+	default:
+		/*
+		 * Other ops are converted, e.g., `a ugt b` => `b ult a`,
+		 * or the expr is not a bv predicate.
+		 */
+		return -EINVAL;
+	}
+
+	if (op == BPF_JEQ) {
+		ENSURE(is_bool_conj(bbt->code) && bbt->vlen == vlen);
+		for (i = 0; i < bbt->vlen; i++)
+			ENSURE(is_bool_eq_of(st, bbt->args[i], lbits[i],
+					     rbits[i]));
+
+		return 0;
+	}
+
+	if (op == BPF_JLT || op == BPF_JLE)
+		return bb_ult(st, bbt, lbits, rbits, vlen, eq);
+
+	/* BPF_JSLT || BPF_JSLE */
+	return bb_slt(st, bbt, lbits, rbits, vlen, eq);
+}
+
+static int check_bb_term(struct bcf_checker_state *st, u32 term_id, u32 bbt_id)
+{
+	return -EOPNOTSUPP;
+}
+
 static int apply_bv_rule(struct bcf_checker_state *st,
 			 struct bcf_proof_step *step)
 {
 	DEFINE_JUMP_TABLE(BCF_BV_RULES);
+	u16 premise_cnt = step->premise_cnt;
+	u16 param_cnt = step->param_cnt;
+	int err;
 
 	goto *checkers[BCF_STEP_RULE(step->rule)];
 
 BITBLAST: { /* Lowering bv term to bitblasted term (boolean circuit) */
-	return -EOPNOTSUPP;
+	struct bcf_expr *bbt_eq, *bv, *bbt;
+
+	ENSURE(!premise_cnt && param_cnt == 1);
+
+	/*
+	 * bbt_eq: must be bv = bbt, where
+	 * - bv: bitvector term or atom (e.g. (+ bv0 bv1), (> bv0 bv1))
+	 * - bbt: bitblasted form (bv_from_bool ...)
+	 */
+	bbt_eq = get_arg_expr(st, step->args[0]);
+	if (IS_ERR(bbt_eq))
+		return PTR_ERR(bbt_eq);
+	ENSURE(is_bool_eq(bbt_eq->code));
+
+	bv = id_to_expr(st, bbt_eq->args[0]);
+	bbt = id_to_expr(st, bbt_eq->args[1]);
+	if (is_bv(bv->code))
+		/* bv term to bbt */
+		err = check_bb_term(st, bbt_eq->args[0], bbt_eq->args[1]);
+	else if (is_bool(bv->code))
+		/* bv atom to bbt */
+		err = check_bb_atom(st, bv, bbt);
+	else
+		return -EINVAL;
+
+	if (err)
+		return err;
+	return set_step_fact_id(st, step->args[0]);
 }
+
 POLY_NORM: { /* Equality of polynomial normal form */
 	return -EOPNOTSUPP;
 }
-- 
2.34.1

